<!DOCTYPE html>
<html lang="ms">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modul Pengesahan</title>
    <script src="https://cdn.jsdelivr.net/npm/face-api.js@latest/dist/face-api.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core@4.1.0/dist/tf-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@4.1.0/dist/tf-backend-webgl.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/hand-pose-detection@2.0.1/dist/hand-pose-detection.min.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');
        :root {
            --primary-color: #007bff;
            --secondary-color: #6c757d;
            --success-color: #28a745;
            --matrix-green: #39FF14;
            --border-radius: 12px;
        }
        body {
            margin: 0;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Poppins', sans-serif;
            cursor: default;
        }
        #app-container {
            width: 100vw;
            height: 100vh;
            background-color: white;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        .hide-cursor {
            cursor: none;
        }
        #video-container, #montage-container {
            position: relative;
            background-color: #000;
            width: 100%;
            flex-grow: 1;
            overflow: hidden;
        }
        #montage-container {
            display: none;
        }
        #video, #montage-video {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover;
        }
        #video {
            transform: scaleX(-1);
            display: none;
        }
        #overlay-canvas {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
        }
        #error-message {
            padding: 1rem; background-color: #f8d7da; color: #721c24;
            text-align: center; display: none;
            position: absolute; top: 0; left: 0; width: 100%; z-index: 300;
        }

        #loading-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 400; /* Pastikan ia di atas skrin mula */
            color: white;
            flex-direction: column;
        }
        #loading-text {
            font-family: 'VT323', monospace;
            font-size: 1.5rem;
            color: var(--matrix-green);
            margin-bottom: 1rem;
        }
        #progress-bar-container {
            width: 80%; max-width: 400px; height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid var(--matrix-green);
        }
        #progress-bar {
            width: 0%; height: 100%;
            background: var(--matrix-green);
            transition: width 1.5s linear;
        }

        #success-screen, #start-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: var(--matrix-green);
            font-family: 'VT323', monospace;
            text-align: center;
        }
        #start-screen {
            z-index: 300;
            cursor: pointer;
        }
        #success-screen {
            z-index: 100;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            display: none;
        }
        #matrix-canvas {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 0;
        }
        .success-content {
            position: relative;
            z-index: 1;
        }
        #success-screen h1, #start-screen h1 {
            font-size: 2.5rem;
            letter-spacing: 3px;
            text-shadow: 0 0 15px var(--matrix-green);
        }
        #success-screen p, #start-screen p {
            font-size: 1.5rem;
        }
         #version-info {
            position: absolute;
            bottom: 1rem;
            right: 1rem;
            font-size: 0.7rem;
            color: #adb5bd;
            z-index: 50;
        }
        #fullscreen-btn {
            position: absolute;
            top: 1.5rem;
            right: 1.5rem;
            width: 32px;
            height: 32px;
            cursor: pointer;
            z-index: 301;
        }
        #fullscreen-btn svg {
            width: 100%;
            height: 100%;
            fill: var(--matrix-green);
        }
    </style>
</head>
<body>

<div id="app-container">
    <div id="error-message"></div>
    <div id="start-screen">
        <h1>Pengesahan identiti akan dimulakan sila bersedia</h1>
        <div id="fullscreen-btn" title="Skrin Penuh">
            <svg viewBox="0 0 24 24"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/></svg>
        </div>
    </div>
    <div id="video-container">
        <video id="video" playsinline autoplay muted></video>
        <canvas id="overlay-canvas"></canvas>
        <div id="version-info">versi 1.6.10 (Modul Pengesahan)</div>
    </div>
    <div id="montage-container">
        <video id="montage-video" src="vid/montaj.mp4" playsinline></video>
    </div>
    <div id="success-screen">
        <canvas id="matrix-canvas"></canvas>
        <div class="success-content">
            <h1 id="success-title"></h1>
            <p id="success-subtitle"></p>
        </div>
    </div>
    <div id="loading-overlay">
        <div id="loading-text">Memuatkan Model AI...</div>
        <div id="progress-bar-container">
            <div id="progress-bar"></div>
        </div>
    </div>
</div>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.7/firebase-app.js";
    import { getFirestore, collection, getDocs } from "https://www.gstatic.com/firebasejs/9.6.7/firebase-firestore.js";

    const firebaseConfig = {
     apiKey: "AIzaSyDrICpXd4ukkpnoFrRleTzEcR87vIoTM3s",
     authDomain: "gimikrt-cf2e4.firebaseapp.com",
     projectId: "gimikrt-cf2e4",
     storageBucket: "gimikrt-cf2e4.appspot.com",
     messagingSenderId: "878304778253",
     appId: "1:878304778253:web:470cc421f6cf6ba0f21d44",
     measurementId: "G-FBMMM8ZG14"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    const appContainer = document.getElementById('app-container');
    const video = document.getElementById('video');
    const overlayCanvas = document.getElementById('overlay-canvas');
    const errorMessage = document.getElementById('error-message');
    const loadingOverlay = document.getElementById('loading-overlay');
    const loadingText = document.getElementById('loading-text');
    const progressBar = document.getElementById('progress-bar');
    const startScreen = document.getElementById('start-screen');
    const fullscreenBtn = document.getElementById('fullscreen-btn');
    const montageContainer = document.getElementById('montage-container');
    const montageVideo = document.getElementById('montage-video');
    const successScreen = document.getElementById('success-screen');
    const successTitle = document.getElementById('success-title');
    const successSubtitle = document.getElementById('success-subtitle');
    const matrixCanvas = document.getElementById('matrix-canvas');

    let stream = null;
    let detectionInterval = null;
    let faceMatcher = null;
    let registeredUsers = [];
    let firstMatchTime = null;
    let handDetector = null;
    let handScanStartTime = null;
    let finalVerificationTimer = null;
    let matrixAnimationId = null;
    let roboticVoice = null;
    let lockedOnUser = null;
    let isReadyForHandScan = false;
    let lastKnownFlippedBox = null;
    let recognitionPhase = 'idle';
    let modelsReady = false;
    let failSafeActive = false;
    let failSafeTimeout = null;
    let mousePosition = { x: 0, y: 0 };

    const FACE_MODEL_URL = 'https://cdn.jsdelivr.net/npm/@vladmandic/face-api/model/';
    
    function showLoadingBar(text, duration) {
        loadingText.textContent = text;
        progressBar.style.transition = `width ${duration}s linear`;
        progressBar.style.width = '0%';
        loadingOverlay.style.display = 'flex';
        setTimeout(() => { progressBar.style.width = '100%'; }, 10);
    }

    function hideLoadingBar() {
        loadingOverlay.style.display = 'none';
        progressBar.style.width = '0%';
    }

    async function initializeAppFlow() {
        showLoadingBar('Memuatkan Model AI...', 3);
        try {
            await Promise.all([
                faceapi.nets.ssdMobilenetv1.loadFromUri(FACE_MODEL_URL),
                faceapi.nets.faceLandmark68Net.loadFromUri(FACE_MODEL_URL),
                faceapi.nets.faceRecognitionNet.loadFromUri(FACE_MODEL_URL)
            ]);
            const model = handPoseDetection.SupportedModels.MediaPipeHands;
            const detectorConfig = {
              runtime: 'mediapipe',
              solutionPath: 'https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240',
              modelType: 'lite'
            };
            handDetector = await handPoseDetection.createDetector(model, detectorConfig);
            
            await loadRegisteredUsers();
            hideLoadingBar();
            modelsReady = true;

        } catch (err) {
            console.error(err);
            showError("Gagal memuatkan komponen utama. Sila cuba lagi.");
            hideLoadingBar();
        }
    }

    async function loadRegisteredUsers() {
        try {
            const querySnapshot = await getDocs(collection(db, "users"));
            const users = [];
            querySnapshot.forEach((doc) => {
                const data = doc.data();
                users.push({
                    name: data.name, position: data.position,
                    descriptor: new Float32Array(data.descriptor)
                });
            });
            registeredUsers = users;
            if (users.length > 0) {
                const labeledDescriptors = users.map(user => new faceapi.LabeledFaceDescriptors(user.name, [user.descriptor]));
                faceMatcher = new faceapi.FaceMatcher(labeledDescriptors, 0.5);
            }
        } catch (e) {
            showError("Gagal memuat turun data pengguna.");
        }
    }
    
    async function startCamera() {
        try {
            if (stream) { video.play(); return true; }
            stream = await navigator.mediaDevices.getUserMedia({ video: true });
            video.srcObject = stream;
            video.style.display = 'block';
            return true;
        } catch (err) {
            showError("Tidak dapat mengakses kamera. Sila benarkan akses dan muat semula.");
            return false;
        }
    }
    
    function stopCamera() {
        if (stream) {
            stream.getTracks().forEach(track => track.stop());
            stream = null;
        }
    }
    
    function drawMatrixText(context, text, x, y, size = 24, align = 'center') {
        context.font = `${size}px VT323, monospace`;
        context.fillStyle = '#39FF14';
        context.shadowColor = '#39FF14';
        context.shadowBlur = 10;
        context.textAlign = align;
        context.fillText(text, x, y);
    }
    
    function drawMatrixInfo(context, box, name, position) {
        const textLines = [ name.toUpperCase(), position.toUpperCase() ];
        context.font = '20px VT323, monospace';
        const textWidth = Math.max(...textLines.map(line => context.measureText(line).width));
        const textHeight = 55;
        let startX = box.x;
        let startY = box.y + box.height + 5;

        if (startY + textHeight > overlayCanvas.height) { startY = box.y - textHeight - 5; }
        if (startX + textWidth + 20 > overlayCanvas.width) { startX = overlayCanvas.width - textWidth - 20; }
        if (startX < 0) { startX = 0; }

        context.fillStyle = 'rgba(0, 0, 0, 0.7)';
        context.fillRect(startX, startY, textWidth + 20, textHeight);
        drawMatrixText(context, textLines[0], startX + 10, startY + 20, 20, 'left');
        drawMatrixText(context, textLines[1], startX + 10, startY + 45, 20, 'left');
    }

    function drawHandBox(context, hands, progress) {
        if (hands.length === 0) return;
        const keypoints = hands[0].keypoints;
        const xCoords = keypoints.map(p => p.x);
        const yCoords = keypoints.map(p => p.y);
        const xMin = Math.min(...xCoords);
        const yMin = Math.min(...yCoords);
        const xMax = Math.max(...xCoords);
        const yMax = Math.max(...yCoords);
        const boxWidth = xMax - xMin;
        const boxHeight = yMax - yMin;
        const padding = 20;
        const paddedXMin = xMin - padding;
        const paddedYMin = yMin - padding;
        const paddedWidth = boxWidth + padding * 2;
        const paddedHeight = boxHeight + padding * 2;
        const scaleX = overlayCanvas.width / video.videoWidth;
        const scaleY = overlayCanvas.height / video.videoHeight;
        const x = paddedXMin * scaleX;
        const y = paddedYMin * scaleY;
        const width = paddedWidth * scaleX;
        const height = paddedHeight * scaleY;
        const flippedX = overlayCanvas.width - x - width;
        context.strokeStyle = 'rgba(40, 167, 69, 0.7)';
        context.lineWidth = 2;
        context.strokeRect(flippedX, y, width, height);
        if (progress !== undefined) {
            drawProgressBar(context, flippedX, y + height + 5, width, 8, progress);
        }
    }
    
    function drawProgressBar(context, x, y, width, height, progress) {
        const greenColor = getComputedStyle(document.documentElement).getPropertyValue('--matrix-green').trim();
        context.fillStyle = 'rgba(255, 255, 255, 0.3)';
        context.fillRect(x, y, width, height);
        context.fillStyle = greenColor;
        context.fillRect(x, y, width * progress, height);
    }

    function initializeTTS() {
        const setVoice = () => {
            const voices = window.speechSynthesis.getVoices();
            roboticVoice = voices.find(voice => voice.name.includes('Google US English')) ||
                           voices.find(voice => voice.name.includes('Samantha')) || 
                           voices.find(voice => voice.name.includes('Microsoft Zira')) || 
                           voices.find(voice => voice.lang === 'en-US') ||
                           voices[0];
        };
        if ('speechSynthesis' in window) {
            if (window.speechSynthesis.onvoiceschanged !== undefined) {
                window.speechSynthesis.onvoiceschanged = setVoice;
            }
            setVoice();
        }
    }

    function speak(text, onEndCallback = null) {
        if ('speechSynthesis' in window && roboticVoice) {
            window.speechSynthesis.cancel();
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.voice = roboticVoice;
            utterance.pitch = 1.1;
            utterance.rate = 0.9;
            if (onEndCallback) utterance.onend = onEndCallback;
            window.speechSynthesis.speak(utterance);
        } else if (onEndCallback) {
            onEndCallback();
        }
    }

    function getGreeting() {
        const hour = new Date().getHours();
        if (hour < 12) return "Good Morning";
        if (hour < 18) return "Good Afternoon";
        return "Good Evening";
    }

    function playDistortionEffect(callback) {
        let count = 0;
        const distortionInterval = setInterval(() => {
            const context = overlayCanvas.getContext('2d');
            const w = overlayCanvas.width;
            const h = overlayCanvas.height;
            for (let i = 0; i < 10; i++) {
                const x = Math.random() * w;
                const y = Math.random() * h;
                const spliceWidth = w - x;
                const spliceHeight = Math.random() * 10 + 5;
                context.drawImage(overlayCanvas, 0, y, spliceWidth, spliceHeight, x, y, spliceWidth, spliceHeight);
                context.drawImage(overlayCanvas, spliceWidth, y, x, spliceHeight, 0, y, x, spliceHeight);
            }
            count++;
            if (count > 20) {
                clearInterval(distortionInterval);
                callback();
            }
        }, 50);
    }
    
    function showSuccessAndMontage() {
        clearAllIntervals();
        stopCamera();
        
        document.getElementById('video-container').style.display = 'none';
        successScreen.style.display = 'flex';

        setTimeout(() => {
            successScreen.style.opacity = 1;
            startMatrixAnimation();
            decodeTextEffect('PENGESAHAN BERJAYA', successTitle, () => {
                decodeTextEffect('Pelancaran Telah Disempurnakan', successSubtitle, null);
            });

            setTimeout(() => {
                successScreen.style.display = 'none';
                stopMatrixAnimation();
                showLoadingBar('Memproses Pelancaran...', 1.5);
                setTimeout(() => {
                    hideLoadingBar();
                    montageContainer.style.display = 'block';
                    montageVideo.play();
                }, 1500);
            }, 4000); 

        }, 10);
    }

    function startRecognition() {
        const setupDetection = () => {
            const displaySize = { width: video.clientWidth, height: video.clientHeight };
            if (displaySize.width === 0 || displaySize.height === 0) {
                setTimeout(setupDetection, 50);
                return;
            }

            lockedOnUser = null;
            isReadyForHandScan = false;
            lastKnownFlippedBox = null;
            failSafeActive = false;
            if(failSafeTimeout) clearTimeout(failSafeTimeout);
            
            appContainer.classList.add('hide-cursor');
            window.addEventListener('keydown', handleEscKey);
            faceapi.matchDimensions(overlayCanvas, displaySize);
            
            recognitionPhase = 'commencing';
            speak("Commencing face recognition.", () => {
                recognitionPhase = 'searching';
                failSafeTimeout = setTimeout(() => {
                    if (!lockedOnUser) failSafeActive = true;
                }, 15000);
            });

            detectionInterval = setInterval(async () => {
                const context = overlayCanvas.getContext('2d');
                context.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
                
                if (recognitionPhase === 'commencing') {
                    drawMatrixText(context, "COMMENCING FACE RECOGNITION", overlayCanvas.width / 2, overlayCanvas.height / 2);
                    return;
                }

                if (lockedOnUser) {
                    let hands = [];
                    if (!failSafeActive) {
                       hands = await handDetector.estimateHands(video, { flipHorizontal: false });
                    }
                    
                    if (lastKnownFlippedBox) {
                        new faceapi.draw.DrawBox(lastKnownFlippedBox, { boxColor: 'rgba(40, 167, 69, 0.7)' }).draw(overlayCanvas);
                        drawMatrixInfo(context, lastKnownFlippedBox, lockedOnUser.name, lockedOnUser.position);
                    }

                    if (isReadyForHandScan) {
                        const isHandDetected = hands.length > 0;
                        if (isHandDetected || (failSafeActive && recognitionPhase === 'verifyingHand')) {
                             if (handScanStartTime === null) handScanStartTime = Date.now();
                            const handProgress = Math.min((Date.now() - handScanStartTime) / 3000, 1);
                            
                            if (failSafeActive) {
                                const box = {x: mousePosition.x - 150, y: mousePosition.y - 200, width: 300, height: 400};
                                new faceapi.draw.DrawBox(box, { boxColor: 'rgba(40, 167, 69, 0.7)' }).draw(overlayCanvas);
                                drawProgressBar(context, box.x, box.y + box.height + 5, box.width, 8, handProgress);
                            } else {
                                drawHandBox(context, hands, handProgress);
                            }
                            
                            if (handProgress >= 1 && !finalVerificationTimer) {
                                finalVerificationTimer = setTimeout(() => {
                                    const greeting = getGreeting();
                                    speak(`Second verification complete. ${greeting} ${lockedOnUser.name}`, () => {
                                        playDistortionEffect(() => setTimeout(showSuccessAndMontage, 500));
                                    });
                                }, 100);
                            }
                        } else {
                            handScanStartTime = null;
                            if(finalVerificationTimer) clearTimeout(finalVerificationTimer);
                            finalVerificationTimer = null;
                            const text = failSafeActive ? "KLIK UNTUK PENGESAHAN TANGAN" : "SHOW YOUR PALM FOR VERIFICATION";
                            drawMatrixText(context, text, overlayCanvas.width / 2, 50, 32);
                        }
                    }
                } else if (failSafeActive) {
                    const box = { x: mousePosition.x - 150, y: mousePosition.y - 200, width: 300, height: 400 };
                    new faceapi.draw.DrawBox(box, { boxColor: 'rgba(255, 193, 7, 0.7)' }).draw(overlayCanvas);
                    drawMatrixText(context, "KLIK UNTUK PENGESAHAN WAJAH", overlayCanvas.width / 2, 50, 32);
                } else {
                    const faceDetections = await faceapi.detectAllFaces(video, new faceapi.SsdMobilenetv1Options({ minConfidence: 0.5 })).withFaceLandmarks().withFaceDescriptors();
                    const resizedDetections = faceapi.resizeResults(faceDetections, displaySize);
                    
                    let recognizedFaceFoundThisFrame = false;

                    if (resizedDetections.length > 0) {
                        for (const detection of resizedDetections) {
                            const { flippedBox, bestMatch } = processDetection(detection);
                            if (bestMatch.label !== 'unknown') {
                                recognizedFaceFoundThisFrame = true;
                                if (firstMatchTime === null) firstMatchTime = Date.now();
                                
                                new faceapi.draw.DrawBox(flippedBox, { boxColor: 'rgba(40, 167, 69, 0.7)' }).draw(overlayCanvas);
                                const elapsedTime = Date.now() - firstMatchTime;

                                if (elapsedTime >= 2000) {
                                    const faceProgress = Math.min((elapsedTime - 2000) / 3000, 1);
                                    drawProgressBar(context, flippedBox.x, flippedBox.y + flippedBox.height + 5, flippedBox.width, 8, faceProgress);

                                    if (faceProgress >= 1) {
                                        const matchedUser = registeredUsers.find(user => user.name === bestMatch.label);
                                        if (matchedUser && !lockedOnUser) {
                                            if(failSafeTimeout) clearTimeout(failSafeTimeout);
                                            failSafeActive = false;
                                            lockedOnUser = { name: matchedUser.name, position: matchedUser.position };
                                            lastKnownFlippedBox = flippedBox;
                                            speak("Identity verified. Standby for second layer security.", () => { isReadyForHandScan = true; });
                                        }
                                    }
                                }
                                
                                if (lockedOnUser) {
                                   drawMatrixInfo(context, flippedBox, lockedOnUser.name, lockedOnUser.position);
                                }
                                break; 
                            }
                        }
                    }
                    
                    if (!recognizedFaceFoundThisFrame) {
                        firstMatchTime = null;
                        if (resizedDetections.length > 0) {
                            const { flippedBox } = processDetection(resizedDetections[0]);
                             new faceapi.draw.DrawBox(flippedBox, { label: `Mencari ID...` }).draw(overlayCanvas);
                        } else {
                            if(recognitionPhase === 'searching') {
                                drawMatrixText(context, "SEMAKAN SEDANG DIJALANKAN", overlayCanvas.width / 2, overlayCanvas.height / 2);
                            }
                        }
                    }
                }
            }, 100);
        }
        setupDetection();
    }

    const processDetection = (detection) => {
        const box = detection.detection.box;
        const paddingX = box.width * 0.3;
        const paddingY = box.height * 0.7;
        const paddedBox = {
            x: box.x - paddingX / 2,
            y: box.y - paddingY * 0.6,
            width: box.width + paddingX,
            height: box.height + paddingY
        };
        const flippedBox = { x: overlayCanvas.width - paddedBox.x - paddedBox.width, y: paddedBox.y, width: paddedBox.width, height: paddedBox.height };
        const bestMatch = faceMatcher.findBestMatch(detection.descriptor);
        return { flippedBox, bestMatch };
    };
    
    function clearAllIntervals() {
        if(detectionInterval) { clearInterval(detectionInterval); detectionInterval = null; }
        if (overlayCanvas.getContext) {
            overlayCanvas.getContext('2d').clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
        }
    }
    
    function decodeTextEffect(finalText, element, callback) {
        let i = 0;
        const alphabet = 'アァカサタナハマヤャラワABCDEFGHIJKLMNOPQRSTUVWXYZ012356789*&%$#@!';
        element.style.opacity = 1;
        element.textContent = '';
        const decodingInterval = setInterval(() => {
            if (i >= finalText.length) {
                clearInterval(decodingInterval);
                if (callback) callback();
                return;
            }
            let currentText = finalText.substring(0, i + 1);
            for (let j = i + 1; j < finalText.length; j++) {
                currentText += alphabet.charAt(Math.floor(Math.random() * alphabet.length));
            }
            element.textContent = currentText;
            i++;
        }, 80);
    }
    
    function startMatrixAnimation() {
        const context = matrixCanvas.getContext('2d');
        matrixCanvas.width = matrixCanvas.clientWidth;
        matrixCanvas.height = matrixCanvas.clientHeight;
        const katakana = 'アァカサタナハマヤャラワガザダバパイィキシチニヒミリヰギジヂビピウゥクスツヌフムユュルグズブヅプエェケセテネヘメレヱゲゼデベペオォコソトノホモヨョロヲゴゾドボポヴッン';
        const alphabet = katakana + 'ABCDEFGHIJKLMNOPQRSTUVWXYZ012356789';
        const fontSize = 16;
        const columns = matrixCanvas.width / fontSize;
        const rainDrops = Array.from({ length: Math.ceil(columns) }).fill(1);
        const draw = () => {
            context.fillStyle = 'rgba(0, 0, 0, 0.05)';
            context.fillRect(0, 0, matrixCanvas.width, matrixCanvas.height);
            context.fillStyle = 'var(--matrix-green)';
            context.font = `${fontSize}px VT323, monospace`;
            for (let i = 0; i < rainDrops.length; i++) {
                const text = alphabet.charAt(Math.floor(Math.random() * alphabet.length));
                context.fillText(text, i * fontSize, rainDrops[i] * fontSize);
                if (rainDrops[i] * fontSize > matrixCanvas.height && Math.random() > 0.975) {
                    rainDrops[i] = 0;
                }
                rainDrops[i]++;
            }
        };
        const animate = () => {
            draw();
            matrixAnimationId = requestAnimationFrame(animate);
        }
        if (matrixAnimationId) cancelAnimationFrame(matrixAnimationId);
        animate();
    }

    function stopMatrixAnimation() {
        if(matrixAnimationId) cancelAnimationFrame(matrixAnimationId);
        matrixAnimationId = null;
    }
    
    function handleEscKey(e) {
        if (e.key === 'Escape') {
            handleCancel();
        }
    }

    function handleCancel() {
        clearAllIntervals();
        stopMatrixAnimation();
        stopCamera();
        appContainer.classList.remove('hide-cursor');
        window.location.href = 'pendaftaran.html';
    }

    function showError(msg) {
        errorMessage.innerText = msg;
        errorMessage.style.display = 'block';
    }
    
    function toggleFullScreen() {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen();
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            }
        }
    }
    
    document.addEventListener('DOMContentLoaded', () => {
        initializeTTS();
        initializeAppFlow();
        
        fullscreenBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleFullScreen();
        });

        montageVideo.addEventListener('ended', () => {
            montageContainer.style.display = 'none';
            const startScreenH1 = startScreen.querySelector('h1');
            startScreenH1.textContent = "PELANCARAN SELESAI";
            startScreen.style.display = 'flex';
            fullscreenBtn.style.display = 'none';
            appContainer.classList.remove('hide-cursor');
        });

        overlayCanvas.addEventListener('mousemove', (e) => {
            const rect = overlayCanvas.getBoundingClientRect();
            mousePosition.x = e.clientX - rect.left;
            mousePosition.y = e.clientY - rect.top;
        });

        overlayCanvas.addEventListener('click', () => {
            if (failSafeActive) {
                if (!lockedOnUser) {
                    lockedOnUser = { 
                        name: "YB PUAN SANDREA NG SHY CHING", 
                        position: "PENGERUSI JAWATANKUASA PERUMAHAN DAN KERAJAAN TEMPATAN" 
                    };
                    lastKnownFlippedBox = { x: mousePosition.x - 150, y: mousePosition.y - 200, width: 300, height: 400 };
                    speak("Identity verified. Standby for second layer security.", () => { 
                        isReadyForHandScan = true; 
                    });
                } else if (isReadyForHandScan) {
                    recognitionPhase = 'verifyingHand';
                }
            }
        });

        startScreen.addEventListener('click', () => {
            if (!modelsReady) { 
                showLoadingBar('Sila tunggu model AI selesai dimuat turun...');
                return;
            }
            startScreen.style.display = 'none';
            startCamera().then(success => {
                if(success) {
                    startRecognition();
                }
            });
        }, { once: true });
    });

</script>
</body>
</html>


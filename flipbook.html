<!-- Projek Pustaka 3D - Versi 1.8.1 (Final Polish) -->
<!DOCTYPE html>
<html lang="ms">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pustaka 3D v1.8.1</title>
    <style>
        body { margin: 0; background-color: #000; overflow: hidden; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            z-index: 100;
            display:block;
            color: white;
            font-family: monospace;
            pointer-events: none;
        }
        .mobile-instructions {
             display: none;
        }
        #fullscreen-modal {
            position: fixed;
            inset: 0;
            background-color: rgba(0,0,0,0.9);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #modal-image {
            max-width: 90vw;
            max-height: 90vh;
            object-fit: contain;
        }
        .modal-nav {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
        }
        .modal-nav:hover {
            background-color: rgba(255, 255, 255, 0.3);
        }
        #modal-prev { left: 20px; }
        #modal-next { right: 20px; }
        #modal-close {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 40px;
        }
    </style>
    <!-- Menguruskan modul Three.js dan add-on -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/"
        }
    }
    </script>
</head>
<body>
    <div id="info">
        <span id="desktop-instructions">Pustaka 3D v1.8.1 | Klik & Seret: Pusing | Skrol: Zum | Klik Buku: Selak</span>
        <span id="mobile-instructions" class="mobile-instructions">Seret 1 Jari: Pusing | Cubit 2 Jari: Zum | Sentuh Buku: Selak</span>
    </div>
    <canvas id="c"></canvas>

    <div id="fullscreen-modal" style="display: none;">
        <button id="modal-close" class="modal-nav" style="top: 20px; right: 20px; width: 50px; height: 50px;">&times;</button>
        <button id="modal-prev" class="modal-nav">◀</button>
        <img id="modal-image" src="">
        <button id="modal-next" class="modal-nav">▶</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TWEEN } from 'three/addons/libs/tween.module.min.js';

        // --- KONFIGURASI BUKU ---
        const IMAGE_PATHS = [
            'img/depan.jpg',     // 0: Muka depan
            'img/gambar_1.jpg',  // 1
            'img/gambar_2.jpg',  // 2
            'img/gambar_3.jpg',  // 3
            'img/gambar_4.jpg',  // 4
            'img/gambar_5.jpg',  // 5
            'img/gambar_6.jpg',  // 6
            'img/gambar_7.jpg',  // 7
            'img/gambar_8.jpg',  // 8
            'img/gambar_9.jpg',  // 9
            'img/gambar_10.jpg', // 10
            'img/gambar_11.jpg', // 11
            'img/gambar_12.jpg', // 12
            'img/gambar_13.jpg', // 13
            'img/gambar_14.jpg', // 14
            'img/belakang.jpg'   // 15: Muka belakang
        ];
        const NUM_PAGES = IMAGE_PATHS.length;
        const NUM_SHEETS = NUM_PAGES / 2;
        
        // --- KELAS PENGURUSAN SCENE ---
        class SceneManager {
            constructor(canvas) {
                this.canvas = canvas;
                this.screenDimensions = { width: window.innerWidth, height: window.innerHeight };
                this.scene = this._buildScene();
                this.renderer = this._buildRenderer(this.screenDimensions);
                this.camera = this._buildCamera(this.screenDimensions);
                this.controls = this._setupControls();
                this.fullscreenButtons = [];
                this._createEnvironment();
                this._setupLights();
            }
            _buildScene() {
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x1a1a1a);
                return scene;
            }
            _buildRenderer({ width, height }) {
                const renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true, powerPreference: "high-performance" });
                renderer.setSize(width, height);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                return renderer;
            }
            _buildCamera({ width, height }) {
                const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
                camera.position.set(0, 5, 6);
                return camera;
            }
            _setupControls() {
                const controls = new OrbitControls(this.camera, this.renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.screenSpacePanning = false;
                controls.minDistance = 2;
                controls.maxDistance = 15;
                controls.maxPolarAngle = Math.PI / 2;
                controls.target.set(0, 2.7, 0);
                return controls;
            }
            _createEnvironment() {
                const floor = new THREE.Mesh(new THREE.CircleGeometry(25, 64), new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.1, roughness: 0.8 }));
                floor.rotation.x = -Math.PI / 2;
                floor.receiveShadow = true;
                this.scene.add(floor);
                const wall = new THREE.Mesh(new THREE.CylinderGeometry(25, 25, 20, 64, 1, true), new THREE.MeshStandardMaterial({ color: 0x222222, side: THREE.BackSide, metalness: 0.2, roughness: 0.9 }));
                wall.position.y = 10;
                this.scene.add(wall);
                const pedestalHeight = 2.5;
                const pedestalBase = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.8, pedestalHeight, 32), new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.1, roughness: 0.4 }));
                pedestalBase.position.y = pedestalHeight / 2;
                pedestalBase.castShadow = true;
                pedestalBase.receiveShadow = true;
                this.scene.add(pedestalBase);
                
                const slabHeight = 0.2;
                const slab = new THREE.Mesh(new THREE.BoxGeometry(5.5, slabHeight, 2.5), new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.1, roughness: 0.4 }));
                slab.position.y = pedestalHeight + (slabHeight / 2);
                slab.castShadow = true;
                slab.receiveShadow = true;
                this.scene.add(slab);

                // FIX: Penambahbaikan pada butang
                const btnGeo = new THREE.CylinderGeometry(0.15, 0.15, 0.05, 32);
                const btnMat = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.5, roughness: 0.5 }); // Warna diubah
                
                const rightButton = new THREE.Mesh(btnGeo, btnMat);
                // Posisi diubah (lebih ke depan)
                rightButton.position.set(1.25, pedestalHeight + slabHeight + 0.025, 0.9);
                // Orientasi dibetulkan (tiada putaran x)
                rightButton.userData = { isFullscreenButton: true, side: 'right' };
                this.scene.add(rightButton);

                const leftButton = new THREE.Mesh(btnGeo.clone(), btnMat.clone());
                 // Posisi diubah (lebih ke depan)
                leftButton.position.set(-1.25, pedestalHeight + slabHeight + 0.025, 0.9);
                // Orientasi dibetulkan (tiada putaran x)
                leftButton.userData = { isFullscreenButton: true, side: 'left' };
                this.scene.add(leftButton);

                this.fullscreenButtons.push(leftButton, rightButton);
            }
            _setupLights() {
                this.scene.add(new THREE.AmbientLight(0xffffff, 0.4));
                const spotLight = new THREE.SpotLight(0xffffff, 1.0, 30, Math.PI * 0.15, 0.5, 1.5);
                spotLight.position.set(8, 12, 8);
                spotLight.target.position.set(0, 2.5, 0);
                spotLight.castShadow = true;
                spotLight.shadow.mapSize.width = 1024;
                spotLight.shadow.mapSize.height = 1024;
                this.scene.add(spotLight, spotLight.target);
            }
            onWindowResize() {
                this.screenDimensions.width = window.innerWidth;
                this.screenDimensions.height = window.innerHeight;
                this.camera.aspect = this.screenDimensions.width / this.screenDimensions.height;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(this.screenDimensions.width, this.screenDimensions.height);
            }
            update() {
                this.controls.update();
                TWEEN.update();
                this.renderer.render(this.scene, this.camera);
            }
        }
        
        // --- KELAS BUKU (KOD STABIL DARIPADA TUAN) ---
        class Book {
             constructor() {
                this.BOOK_WIDTH = 2.5;
                this.BOOK_DEPTH = 1.8;
                this.PAGE_THICKNESS = 0.008; 
                this.SPINE_OFFSET = 0.01;
                
                this.sheets = [];
                this.currentSheetIndex = 0;
                this.isAnimating = false;

                this.mesh = new THREE.Group();
                this.mesh.position.set(0, 2.8, 0);
                this.mesh.rotation.x = -Math.PI / 2;

                this.textureLoader = new THREE.TextureLoader();
                this.textures = IMAGE_PATHS.map(path => {
                    const texture = this.textureLoader.load(path);
                    texture.flipY = true;
                    return texture;
                });
                
                this._createBook();
                this._createClickTargets();
            }

            _createBook() {
                const pageGeometry = new THREE.PlaneGeometry(this.BOOK_WIDTH, this.BOOK_DEPTH);
                pageGeometry.translate(this.BOOK_WIDTH / 2, 0, 0);

                for (let i = 0; i < NUM_SHEETS; i++) {
                    const sheetGroup = new THREE.Group();
                    
                    const frontTexture = this.textures[i * 2];
                    const backTexture = this.textures[i * 2 + 1];
                    
                    backTexture.center.set(0.5, 0.5);
                    backTexture.rotation = Math.PI;

                    const frontMaterial = new THREE.MeshStandardMaterial({ map: frontTexture, side: THREE.FrontSide, roughness: 0.6 });
                    const backMaterial = new THREE.MeshStandardMaterial({ map: backTexture, side: THREE.FrontSide, roughness: 0.6 });
                    const frontPage = new THREE.Mesh(pageGeometry, frontMaterial);
                    const backPage = new THREE.Mesh(pageGeometry, backMaterial);
                    
                    backPage.rotation.x = Math.PI;
                    sheetGroup.add(frontPage, backPage);
                    sheetGroup.position.z = -i * this.PAGE_THICKNESS;
                    
                    sheetGroup.renderOrder = i;
                    frontPage.renderOrder = i;
                    backPage.renderOrder = i;

                    this.sheets.push(sheetGroup);
                    this.mesh.add(sheetGroup);
                }

                const spineHeight = NUM_SHEETS * this.PAGE_THICKNESS;
                const spineGeometry = new THREE.BoxGeometry(this.SPINE_OFFSET, this.BOOK_DEPTH, spineHeight);
                const spineMaterial = new THREE.MeshStandardMaterial({ color: 0x3a2e29, roughness: 0.5 });
                const spine = new THREE.Mesh(spineGeometry, spineMaterial);
                spine.position.set(0, 0, -spineHeight / 2 + (this.PAGE_THICKNESS / 2));
                spine.castShadow = true;
                this.mesh.add(spine);
            }

            _createClickTargets() {
                const targetGeometry = new THREE.PlaneGeometry(this.BOOK_WIDTH, this.BOOK_DEPTH);
                const targetMaterial = new THREE.MeshBasicMaterial({ visible: false, side: THREE.DoubleSide });
                this.rightClickTarget = new THREE.Mesh(targetGeometry, targetMaterial);
                this.rightClickTarget.position.set(this.BOOK_WIDTH / 2, 0.01, 0);
                this.leftClickTarget = new THREE.Mesh(targetGeometry.clone(), targetMaterial.clone());
                this.leftClickTarget.position.set(-this.BOOK_WIDTH / 2, 0.01, 0);
                this.mesh.add(this.rightClickTarget, this.leftClickTarget);
            }
            
            turnPage(direction) {
                if (this.isAnimating) return;
                const isForward = direction === 'forward';
                if (isForward && this.currentSheetIndex >= this.sheets.length) return;
                if (!isForward && this.currentSheetIndex <= 0) return;
                this.isAnimating = true;

                const sheetIndex = isForward ? this.currentSheetIndex : this.currentSheetIndex - 1;
                const sheetToTurn = this.sheets[sheetIndex];
                const startAngle = sheetToTurn.rotation.y;
                const endAngle = isForward ? -Math.PI : 0;
                const targetZ = isForward ? sheetIndex * this.PAGE_THICKNESS - 0.05 : -sheetIndex * this.PAGE_THICKNESS;
                const animationProxy = { angle: startAngle, z: sheetToTurn.position.z };

                new TWEEN.Tween(animationProxy)
                    .to({ angle: endAngle, z: targetZ }, 1200)
                    .easing(TWEEN.Easing.Sinusoidal.InOut)
                    .onUpdate(() => {
                        sheetToTurn.rotation.y = animationProxy.angle;
                        sheetToTurn.position.z = animationProxy.z; 
                    })
                    .onComplete(() => {
                        this.currentSheetIndex += isForward ? 1 : -1;
                        this.isAnimating = false;
                    })
                    .start();
            }
        }

        // --- NEW: UI Controller Class ---
        class UIController {
            constructor() {
                this.modal = document.getElementById('fullscreen-modal');
                this.image = document.getElementById('modal-image');
                this.prevBtn = document.getElementById('modal-prev');
                this.nextBtn = document.getElementById('modal-next');
                this.closeBtn = document.getElementById('modal-close');
                this.currentIndex = 0;
                this.prevBtn.addEventListener('click', () => this.navigate(-1));
                this.nextBtn.addEventListener('click', () => this.navigate(1));
                this.closeBtn.addEventListener('click', () => this.close());
            }
            open(pageIndex) {
                this.currentIndex = pageIndex;
                this.update();
                this.modal.style.display = 'flex';
            }
            close() { this.modal.style.display = 'none'; }
            navigate(direction) {
                this.currentIndex += direction;
                this.update();
            }
            update() {
                this.prevBtn.style.display = (this.currentIndex > 0) ? 'flex' : 'none';
                this.nextBtn.style.display = (this.currentIndex < NUM_PAGES - 1) ? 'flex' : 'none';
                if (this.currentIndex >= 0 && this.currentIndex < NUM_PAGES) {
                    this.image.src = IMAGE_PATHS[this.currentIndex];
                }
            }
        }

        // --- KELAS APLIKASI UTAMA ---
        class FlipbookApp {
            constructor() {
                this.canvas = document.getElementById('c');
                this.sceneManager = new SceneManager(this.canvas);
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                this.book = new Book();
                this.sceneManager.scene.add(this.book.mesh);
                this.uiController = new UIController();
                this.isMobile = 'ontouchstart' in window;
                this.touchStartPos = new THREE.Vector2();
                this.touchStartTime = 0;
                this._setupEventListeners();
                this.animate();
            }

            _setupEventListeners() {
                window.addEventListener('resize', () => this.sceneManager.onWindowResize());
                if (this.isMobile) {
                    document.getElementById('desktop-instructions').style.display = 'none';
                    document.getElementById('mobile-instructions').style.display = 'inline';
                    this.canvas.addEventListener('touchstart', this.onTouchStart.bind(this));
                    this.canvas.addEventListener('touchend', this.onTouchEnd.bind(this));
                } else {
                    this.canvas.addEventListener('click', this.onMouseClick.bind(this));
                }
            }

            onTouchStart(event) {
                if (event.touches.length === 1) {
                    this.touchStartPos.set(event.touches[0].clientX, event.touches[0].clientY);
                    this.touchStartTime = Date.now();
                }
            }

            onTouchEnd(event) {
                if (event.touches.length > 0) return;
                const touchEndPos = new THREE.Vector2(event.changedTouches[0].clientX, event.changedTouches[0].clientY);
                const distance = this.touchStartPos.distanceTo(touchEndPos);
                const touchTime = Date.now() - this.touchStartTime;
                if (touchTime < 250 && distance < 10) {
                    this.handleTap(event.changedTouches[0]);
                }
            }
            
            handleTap(touchEvent) {
                if (this.book.isAnimating) return;
                
                this.mouse.x = (touchEvent.clientX / window.innerWidth) * 2 - 1;
                this.mouse.y = - (touchEvent.clientY / window.innerHeight) * 2 + 1;
                this.raycaster.setFromCamera(this.mouse, this.sceneManager.camera);
                
                const fullscreenIntersects = this.raycaster.intersectObjects(this.sceneManager.fullscreenButtons);
                if(fullscreenIntersects.length > 0) {
                    const side = fullscreenIntersects[0].object.userData.side;
                    if(side === 'right') {
                        this.uiController.open(this.book.currentSheetIndex * 2);
                    } else { // left
                        if(this.book.currentSheetIndex > 0) {
                           this.uiController.open((this.book.currentSheetIndex * 2) - 1);
                        }
                    }
                    return;
                }

                const turnTargets = [this.book.leftClickTarget, this.book.rightClickTarget];
                const turnIntersects = this.raycaster.intersectObjects(turnTargets);
                
                if (turnIntersects.length > 0) {
                    const clickedObject = turnIntersects[0].object;
                    if (clickedObject === this.book.rightClickTarget) {
                        this.book.turnPage('forward');
                    } else if (clickedObject === this.book.leftClickTarget) {
                        this.book.turnPage('backward');
                    }
                }
            }
            
            onMouseClick(event) {
                this.handleTap(event);
            }
            
            animate() {
                requestAnimationFrame(this.animate.bind(this));
                this.sceneManager.update();
            }
        }

        const app = new FlipbookApp();
    </script>
</body>
</html>

